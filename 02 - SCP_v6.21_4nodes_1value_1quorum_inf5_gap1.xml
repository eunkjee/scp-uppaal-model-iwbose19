<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>const int N = 4; // total number of nodes
const int F = 0; // total number of faulty nodes
typedef int[0,N-F-1] n_id;
//typedef int[N-F,N-1] f_id;

const int THR = 67; // quorum threshold number

const int V = 1; // maximum number of values in nomination state
typedef int[0,V-1] v_id;
const int ZEROCOUNTER = 0;
const bool NOVALUE[V] =
    {false};

const int SLOTMAX = V;
typedef int[0,SLOTMAX] s_id;

const int INFINITY = 5;
const int INTERVAL = 20;
const int MAXGAP = 1;

// states
const int SCPPrepare = 0;
const int SCPCommit = 1;
const int SCPExternalize = 2;
//const int SCPNomination = 3;

chan sthNominated[N-F];
chan nominationDone[N-F];
broadcast chan slotDone;
broadcast chan slotSuccess;
broadcast chan slotFail;
broadcast chan slotUnknown;
broadcast chan slotStarted[SLOTMAX+1];

typedef struct {
    int[0,N] threshold;
    int[0,N] validators[N];
} SCPQuorumSlice;
SCPQuorumSlice qs[N] =
// the entire of nodes are in one quorum
    {{0, {0, 1, 2, 3}},
     {0, {0, 1, 2, 3}},
     {0, {0, 1, 2, 3}},
     {0, {0, 1, 2, 3}}};

int[0,N] totalValidators[N] =
    {0, 0, 0, 0};

int[0,SLOTMAX] slotCur = 0;

// faulty nodes should not have any input values!
bool higherlayerInput[N][V] =
    {{true},  // 1
     {true},  // 1
     {true},  // 1
     {true}}; // 1

int[0,INFINITY] round[N] =
    {0, 0, 0, 0};

typedef struct {
    bool voted[V];
    bool accepted[V];
} SCPNominationState;
SCPNominationState nominationStates[N] =
    {{{false}, {false}},
     {{false}, {false}},
     {{false}, {false}},
     {{false}, {false}}};

bool nominatedValues[N][V] =
    {{false},
     {false},
     {false},
     {false}};

bool ballotDone[N] =
    {false, false, false, false};

typedef struct {
    int[0,INFINITY] counter;
    bool value[V];
} SCPBallot;

typedef struct {
    int[0,2] curState;
    SCPBallot b;
    SCPBallot p;
    meta SCPBallot pp;
    SCPBallot h;
    SCPBallot c;
} SCPBallotState;
SCPBallotState ballotStates[N];

// check if valueL &lt; valueR
bool isLessValue(const bool &amp;valueL[V], const bool &amp;valueR[V]) {
    int[-1, V-1] i;

    for (i = V-1; i &gt;= 0; i--) {
        if (valueL[i] == false &amp;&amp; valueR[i] == true) {
            return true;
        }
        else if (valueL[i] == true &amp;&amp; valueR[i] == false) {
            return false;
        }
    }
    return false; // valueL == valueR
}
</declaration>
	<template>
		<name>NodeCheckNomination</name>
		<parameter>const v_id valueID</parameter>
		<location id="id0" x="501" y="119">
			<name x="442" y="136">CheckNominationFail</name>
		</location>
		<location id="id1" x="501" y="-119">
			<name x="425" y="-153">CheckNominationSuccess</name>
		</location>
		<location id="id2" x="272" y="0">
			<name x="297" y="-8">CheckNominationStarted</name>
		</location>
		<location id="id3" x="0" y="0">
			<name x="17" y="-34">StartCheckNomination</name>
		</location>
		<init ref="id3"/>
		<transition>
			<source ref="id0"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="18" y="102">slotSuccess?</label>
			<nail x="0" y="119"/>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="18" y="-136">slotSuccess?</label>
			<nail x="0" y="-119"/>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id0"/>
			<label kind="guard" x="246" y="25">exists (i : n_id) nominatedValues[i][valueID]
&amp;&amp; forall (i : n_id) ballotStates[i].curState != SCPPrepare
&amp;&amp; exists (i : n_id) !nominatedValues[i][valueID]</label>
			<label kind="synchronisation" x="365" y="93">slotDone?</label>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id1"/>
			<label kind="guard" x="17" y="-93">exists (i : n_id) nominatedValues[i][valueID]
&amp;&amp; forall (i : n_id) ballotStates[i].curState != SCPPrepare &amp;&amp; nominatedValues[i][valueID]</label>
			<label kind="synchronisation" x="263" y="-51">slotDone?</label>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id2"/>
			<label kind="synchronisation" x="17" y="0">slotStarted[slotCur]?</label>
		</transition>
	</template>
	<template>
		<name>NodeFaulty</name>
		<parameter>const n_id nodeID</parameter>
		<location id="id4" x="0" y="0">
		</location>
		<init ref="id4"/>
	</template>
	<template>
		<name>NodeSlot</name>
		<parameter>const s_id slotID</parameter>
		<declaration>bool hasHigherlayerInput() {
    for (n : n_id) {
        if (higherlayerInput[n] != NOVALUE) {
            return true;
        }
    }
    return false;
}

bool isAllAgreed(const bool &amp;value[V]) {
    for (n : n_id) {
        if (ballotStates[n].c.value != value) {
            return false;
        }
    }
    return true;
}

void clearInputs(const bool &amp;value[V]) {
    for (v : v_id) {
        if (value[v]) {
            for (n : n_id) {
                higherlayerInput[n][v] = false;
            }
        }
    }
}

void doSuccess() {
    clearInputs(ballotStates[0].c.value);
    if (slotCur &lt; SLOTMAX) {
        slotCur++;
    }
}

bool canNextRound(int[0,N-F-1] nID) {
    int[0,INFINITY] min = INFINITY;

    if (round[nID] == INFINITY) {
        return false;
    }

    for (n : int[0,N-1]) {
        if (qs[nID].validators[n] != N) {
            if (round[qs[nID].validators[n]] &lt;= min) {
                min = round[qs[nID].validators[n]];
            }
        }
    }
    return (round[nID] - min) &lt; MAXGAP;
}

bool canNextCounter(int[0,N-F-1] nID) {
    int[0,INFINITY] min = INFINITY;

    if (nominatedValues[nID] == NOVALUE) {
        return false;
    }

    if (ballotStates[nID].b.counter == INFINITY) {
        return false;
    }

    for (n : int[0,N-1]) {
        if (qs[nID].validators[n] != N) {
            if (ballotStates[qs[nID].validators[n]].b.counter &lt;= min) {
                min = ballotStates[qs[nID].validators[n]].b.counter;
            }
        }
    }
    return (ballotStates[nID].b.counter - min) &lt; MAXGAP;
}
</declaration>
		<location id="id5" x="-204" y="-136">
			<name x="-187" y="-161">SlotDeadlock</name>
		</location>
		<location id="id6" x="544" y="-136">
			<name x="442" y="-170">SlotUnknown</name>
		</location>
		<location id="id7" x="544" y="-8">
			<name x="450" y="-42">SlotSuccess</name>
		</location>
		<location id="id8" x="544" y="110">
			<name x="484" y="76">SlotFail</name>
		</location>
		<location id="id9" x="314" y="-8">
			<name x="331" y="-42">SlotDone</name>
		</location>
		<location id="id10" x="33" y="-8">
			<name x="-51" y="0">SlotStarted</name>
		</location>
		<location id="id11" x="-204" y="-8">
			<name x="-187" y="-42">StartSlot</name>
		</location>
		<init ref="id11"/>
		<transition>
			<source ref="id10"/>
			<target ref="id5"/>
			<label kind="guard" x="-187" y="-85">forall (i : n_id) not canNextRound(i) &amp;&amp; not canNextCounter(i)
&amp;&amp; forall (i : n_id) ballotStates[i].curState != SCPExternalize</label>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id6"/>
			<label kind="guard" x="51" y="-127">forall (i : n_id) (round[i] == INFINITY &amp;&amp; nominatedValues[i] == NOVALUE)
&amp;&amp; exists (i : n_id) nominationStates[i].accepted != NOVALUE</label>
			<label kind="synchronisation" x="51" y="-170">slotUnknown!</label>
			<nail x="34" y="-136"/>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id8"/>
			<label kind="guard" x="51" y="144">forall (i : n_id) (round[i] == INFINITY &amp;&amp; nominationStates[i].accepted == NOVALUE)</label>
			<label kind="synchronisation" x="51" y="170">slotFail!</label>
			<nail x="34" y="110"/>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id8"/>
			<label kind="guard" x="331" y="119">!isAllAgreed(ballotStates[0].c.value)</label>
			<nail x="314" y="110"/>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id7"/>
			<label kind="guard" x="331" y="0">isAllAgreed(ballotStates[0].c.value)</label>
			<label kind="synchronisation" x="331" y="25">slotSuccess!</label>
			<label kind="assignment" x="331" y="51">doSuccess()</label>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id9"/>
			<label kind="guard" x="51" y="0">forall (i : n_id) ballotDone[i]</label>
			<label kind="synchronisation" x="51" y="25">slotDone!</label>
		</transition>
		<transition>
			<source ref="id11"/>
			<target ref="id10"/>
			<label kind="guard" x="-187" y="0">slotCur == slotID
&amp;&amp; hasHigherlayerInput()</label>
			<label kind="synchronisation" x="-187" y="51">slotStarted[slotCur]!</label>
		</transition>
	</template>
	<template>
		<name x="9" y="9">NodeNomination</name>
		<parameter>const n_id nodeID</parameter>
		<declaration>clock n_clockRound;

bool canNextRound() {
    int[0,INFINITY] min = INFINITY;

    if (round[nodeID] == INFINITY) {
        return false;
    }

    for (n : int[0,N-1]) {
        if (qs[nodeID].validators[n] != N) {
            if (round[qs[nodeID].validators[n]] &lt;= min) {
                min = round[qs[nodeID].validators[n]];
            }
        }
    }
    return (round[nodeID] - min) &lt; MAXGAP;
}

void resetNominationState() {
    qs[nodeID].threshold = 0;
    totalValidators[nodeID] = 0;
    round[nodeID] = 0;
    n_clockRound = 0;
    for (v : v_id) {
        nominatedValues[nodeID][v] = false;
        nominationStates[nodeID].voted[v] = false;
        nominationStates[nodeID].accepted[v] = false;
    }
}

void initNominationState() {
    for (n : int[0,N-1]) {
        if (qs[nodeID].validators[n] != N) {
            totalValidators[nodeID]++;
        }
    }
   qs[nodeID].threshold = totalValidators[nodeID]*THR/100 + 1;
}

void processMessageNomination() {
    int[0,N] cntValues = 0;
    int[0,N] cntValues_qs = 0;

    // blocking threshold check for accept nomination
    for (v : v_id) {
        cntValues = 0;

        for (n : int[0,N-1]) {
            if (qs[nodeID].validators[n] != N
                &amp;&amp; qs[nodeID].validators[n] != nodeID
                &amp;&amp; nominationStates[qs[nodeID].validators[n]].accepted[v]) {
                cntValues++;
            }
        }

        if (cntValues &gt; totalValidators[nodeID] - qs[nodeID].threshold
            &amp;&amp; !nominationStates[nodeID].accepted[v]) {
            nominationStates[nodeID].accepted[v] = true;
            nominationStates[nodeID].voted[v] = false;
        }
    }

    // quorum threshold check for vote nomination
    for (v : v_id) {
        cntValues = 0;

        for (n : int[0,N-1]) {
            if (qs[nodeID].validators[n] != N) {
                cntValues_qs = 0;

                for (n_qs : int[0,N-1]) {
                    if (qs[qs[nodeID].validators[n]].validators[n_qs] != N) {
                        if (nominationStates[qs[qs[nodeID].validators[n]].validators[n_qs]].accepted[v]) {
                            cntValues_qs++;
                        }
                        else if (nominationStates[qs[qs[nodeID].validators[n]].validators[n_qs]].voted[v]) {
                            cntValues_qs++;
                        }
                    }
                }

                if (cntValues_qs &gt;= qs[qs[nodeID].validators[n]].threshold) {
                    cntValues++;
                }
            }
        }

        if (cntValues &gt;= qs[nodeID].threshold
            &amp;&amp; !nominationStates[nodeID].accepted[v]) {
            nominationStates[nodeID].accepted[v] = true;
            nominationStates[nodeID].voted[v] = false;
        }
    }

    // quorum threshold check for accept nomination
    for (v : v_id) {
        cntValues = 0;

        for (n : int[0,N-1]) {
            if (qs[nodeID].validators[n] != N) {
                cntValues_qs = 0;

                for (n_qs : int[0,N-1]) {
                    if (qs[qs[nodeID].validators[n]].validators[n_qs] != N) {
                        if (nominationStates[qs[qs[nodeID].validators[n]].validators[n_qs]].accepted[v]) {
                            cntValues_qs++;
                        }
                    }
                }

                if (cntValues_qs &gt;= qs[qs[nodeID].validators[n]].threshold) {
                    cntValues++;
                }
            }
        }

        if (cntValues &gt;= qs[nodeID].threshold) {
            if (!nominationStates[nodeID].accepted[v]) {
                nominationStates[nodeID].accepted[v] = true;
                nominationStates[nodeID].voted[v] = false;
            }

            if (!nominatedValues[nodeID][v]) {
                nominatedValues[nodeID][v] = true;
            }
        }
    }
}

int getHighestPriorityNode(int[0,INFINITY] round) {
    int highest = round % N;
    if (qs[nodeID].validators[highest] == N) {
        return nodeID;
    }
    return highest;
}

void getHigherlayerInput() {
    for (v : v_id) {
        if (higherlayerInput[nodeID][v]
            &amp;&amp; !nominationStates[nodeID].accepted[v]
            &amp;&amp; !nominationStates[nodeID].voted[v]) {
            nominationStates[nodeID].voted[v] = true;
            return;
        }
    }
}

void doEchoing(int[0,N] nodeIDHighest) {
    for (v : v_id) {
        if ((nominationStates[nodeIDHighest].accepted[v]
                || nominationStates[nodeIDHighest].voted[v])
            &amp;&amp; !nominationStates[nodeID].accepted[v]
            &amp;&amp; !nominationStates[nodeID].voted[v]) {
            nominationStates[nodeID].voted[v] = true;
        }
    }
}

void newRound(bool hasNominatedValues) {
    int[0,N] nodeIDHighest;

    processMessageNomination();

    if (round[nodeID]&lt;INFINITY) {
        round[nodeID]++;
    }

    if (!hasNominatedValues) {
        nodeIDHighest = getHighestPriorityNode(round[nodeID]);
        if (nodeIDHighest == nodeID) {
            getHigherlayerInput();
        }
        else {
            doEchoing(nodeIDHighest);
        }
    }

    n_clockRound = 0;
}
</declaration>
		<location id="id12" x="-765" y="-637">
		</location>
		<location id="id13" x="-867" y="-637">
		</location>
		<location id="id14" x="-298" y="-603">
			<name x="-417" y="-629">NominationDone</name>
		</location>
		<location id="id15" x="-544" y="-603">
			<name x="-527" y="-629">SthNominated</name>
		</location>
		<location id="id16" x="-816" y="-603">
			<name x="-773" y="-629">NominationStarted</name>
		</location>
		<location id="id17" x="-1028" y="-603">
			<name x="-1011" y="-629">StartNomination</name>
		</location>
		<init ref="id17"/>
		<transition>
			<source ref="id16"/>
			<target ref="id12"/>
			<label kind="synchronisation" x="-782" y="-671">slotUnknown?</label>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id13"/>
			<label kind="synchronisation" x="-909" y="-671">slotFail?</label>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id15"/>
			<label kind="guard" x="-586" y="-765">n_clockRound &gt; round[nodeID]
&amp;&amp; canNextRound()</label>
			<label kind="assignment" x="-586" y="-722">newRound(true)</label>
			<nail x="-586" y="-697"/>
			<nail x="-501" y="-697"/>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id16"/>
			<label kind="guard" x="-858" y="-501">nominatedValues[nodeID] == NOVALUE
&amp;&amp; n_clockRound &gt; 1 + round[nodeID]
&amp;&amp; canNextRound()</label>
			<label kind="assignment" x="-858" y="-433">newRound(false)</label>
			<nail x="-858" y="-510"/>
			<nail x="-773" y="-510"/>
		</transition>
		<transition>
			<source ref="id14"/>
			<target ref="id17"/>
			<label kind="synchronisation" x="-1011" y="-875">slotSuccess?</label>
			<label kind="assignment" x="-1011" y="-850">resetNominationState()</label>
			<nail x="-298" y="-816"/>
			<nail x="-1028" y="-816"/>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id14"/>
			<label kind="synchronisation" x="-527" y="-595">nominationDone[nodeID]?</label>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id15"/>
			<label kind="guard" x="-799" y="-595">nominatedValues[nodeID] != NOVALUE</label>
			<label kind="synchronisation" x="-756" y="-569">sthNominated[nodeID]!</label>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id16"/>
			<label kind="synchronisation" x="-1011" y="-595">slotStarted[slotCur]?</label>
			<label kind="assignment" x="-1011" y="-569">initNominationState()</label>
		</transition>
	</template>
	<template>
		<name>NodeBallot</name>
		<parameter>const n_id nodeID</parameter>
		<declaration>clock n_clockBCounter;

void updatebValue() {
    if (ballotStates[nodeID].h.value != NOVALUE) {
        ballotStates[nodeID].b.value = ballotStates[nodeID].h.value;
    }
    else if (nominatedValues[nodeID] != NOVALUE) {
        if (ballotStates[nodeID].b.value != nominatedValues[nodeID]) {
            ballotStates[nodeID].b.value = nominatedValues[nodeID];
        }
    }
    else if (ballotStates[nodeID].p.value != NOVALUE) {
        ballotStates[nodeID].b.value = ballotStates[nodeID].p.value;
    }
}

void resetBallotState() {
    ballotDone[nodeID] = false;

    ballotStates[nodeID].curState = SCPPrepare;
    ballotStates[nodeID].b.counter = 0;
    ballotStates[nodeID].b.value = NOVALUE;
    ballotStates[nodeID].p.counter = 0;
    ballotStates[nodeID].p.value = NOVALUE;
    ballotStates[nodeID].pp.counter = 0;
    ballotStates[nodeID].pp.value = NOVALUE;
    ballotStates[nodeID].h.counter = 0;
    ballotStates[nodeID].h.value = NOVALUE;
    ballotStates[nodeID].c.counter = 0;
    ballotStates[nodeID].c.value = NOVALUE;
}

void initBallotState() {
    ballotStates[nodeID].b.counter = 1;
    ballotStates[nodeID].b.value = nominatedValues[nodeID];
}

bool hasGEbCounter() {
    bool hasCounter = false;
    int[0,INFINITY] min = INFINITY;

    for (n : int[0,N-1]) {
        if (qs[nodeID].validators[n] != N) {
            if (qs[nodeID].validators[n] != nodeID
                &amp;&amp; ballotStates[qs[nodeID].validators[n]].b.counter &gt;= ballotStates[nodeID].b.counter) {
                hasCounter = true;
            }

            if (ballotStates[qs[nodeID].validators[n]].b.counter &lt;= min) {
                min = ballotStates[qs[nodeID].validators[n]].b.counter;
            }
        }
    }

    if (hasCounter
        &amp;&amp; (ballotStates[nodeID].b.counter - min) &lt; MAXGAP) {
        return true;
    }
    else {
        return false;
    }
}

bool checkAcceptedPrepareQuorum(int[0,N] nodeIndex, const SCPBallot &amp;candidate) {
    int[0,N] cntQuorumTH = 0;
    bool isVBlocked = false;

    for (n : int[0,N-1]) {
        if (N - n + cntQuorumTH &lt; qs[nodeIndex].threshold) {
            return false;
        }
        if (qs[nodeIndex].validators[n] != N) {
            isVBlocked = false;
            if (ballotStates[qs[nodeIndex].validators[n]].curState == SCPPrepare) {
                if ((ballotStates[qs[nodeIndex].validators[n]].p.counter != 0
                        &amp;&amp; (ballotStates[qs[nodeIndex].validators[n]].p.value == candidate.value
                            &amp;&amp; ballotStates[qs[nodeIndex].validators[n]].p.counter &gt;= candidate.counter))
                    || (ballotStates[qs[nodeIndex].validators[n]].pp.counter != 0
                        &amp;&amp; (ballotStates[qs[nodeIndex].validators[n]].pp.value == candidate.value
                            &amp;&amp; ballotStates[qs[nodeIndex].validators[n]].pp.counter &gt;= candidate.counter))) {
                    if (qs[nodeIndex].validators[n] != nodeIndex) {
                        cntQuorumTH++;
                        isVBlocked = true;
                    }
                }
                if (!isVBlocked
                    &amp;&amp; (ballotStates[qs[nodeIndex].validators[n]].b.value == candidate.value
                        &amp;&amp; ballotStates[qs[nodeIndex].validators[n]].b.counter &gt;= candidate.counter)) {
                    cntQuorumTH++;
                }
            }
            else if (ballotStates[qs[nodeIndex].validators[n]].curState == SCPCommit) {
                if (ballotStates[qs[nodeIndex].validators[n]].p.value == candidate.value
                    &amp;&amp; ballotStates[qs[nodeIndex].validators[n]].p.counter &gt;= candidate.counter) {
                    if (qs[nodeIndex].validators[n] != nodeIndex) {
                        cntQuorumTH++;
                        isVBlocked = true;
                    }
                }
                if (!isVBlocked
                    &amp;&amp; ballotStates[qs[nodeIndex].validators[n]].b.value == candidate.value) {
                    cntQuorumTH++;
                }
            }
            else {// ballotStates[cur].curState == SCPExternalize
                if (ballotStates[qs[nodeIndex].validators[n]].c.value == candidate.value) {
                    if (qs[nodeIndex].validators[n] != nodeIndex) {
                        cntQuorumTH++;
                        isVBlocked = true;
                    }
                }
                if (!isVBlocked
                    &amp;&amp; ballotStates[qs[nodeIndex].validators[n]].c.value == candidate.value) {
                    cntQuorumTH++;
                }
            }

            if (cntQuorumTH &gt;= qs[nodeIndex].threshold) {
                return true;
            }
        }
    }

    return false;
}

bool checkAcceptedPrepare(const SCPBallot &amp;candidate) {
    int[0,N] cntVBlockTH = 0;
    int[0,N] cntQuorumTH = 0;

    if (ballotStates[nodeID].curState == SCPCommit) {
        if (!(ballotStates[nodeID].p.value == candidate.value
            &amp;&amp; ballotStates[nodeID].p.counter &lt; candidate.counter)) {
            return false;
        }
    }

    if (ballotStates[nodeID].pp.counter != 0
        &amp;&amp; (ballotStates[nodeID].pp.counter &gt; candidate.counter
            || (ballotStates[nodeID].pp.counter == candidate.counter
                &amp;&amp; !(isLessValue(ballotStates[nodeID].pp.value, candidate.value))))) { // ballotStates[nodeID].pp.value &gt;= candidate.value
        return false;
    }

    if (ballotStates[nodeID].p.counter != 0
        &amp;&amp; (ballotStates[nodeID].p.value == candidate.value
            &amp;&amp; ballotStates[nodeID].p.counter &gt;= candidate.counter)) {
        return false;
    }

    for (n : int[0,N-1]) {
        if (qs[nodeID].validators[n] != N) {
            if (ballotStates[qs[nodeID].validators[n]].curState == SCPPrepare) {
                if ((ballotStates[qs[nodeID].validators[n]].p.counter != 0
                        &amp;&amp; (ballotStates[qs[nodeID].validators[n]].p.value == candidate.value
                            &amp;&amp; ballotStates[qs[nodeID].validators[n]].p.counter &gt;= candidate.counter))
                    || (ballotStates[qs[nodeID].validators[n]].pp.counter != 0
                        &amp;&amp; (ballotStates[qs[nodeID].validators[n]].pp.value == candidate.value
                            &amp;&amp; ballotStates[qs[nodeID].validators[n]].pp.counter &gt;= candidate.counter))) {
                    if (qs[nodeID].validators[n] != nodeID) {
                        cntVBlockTH++;
                    }
                }
            }
            else if (ballotStates[qs[nodeID].validators[n]].curState == SCPCommit) {
                if (ballotStates[qs[nodeID].validators[n]].p.value == candidate.value
                    &amp;&amp; ballotStates[qs[nodeID].validators[n]].p.counter &gt;= candidate.counter) {
                    if (qs[nodeID].validators[n] != nodeID) {
                        cntVBlockTH++;
                    }
                }
            }
            else {// ballotStates[qs[nodeID].validators[n]].curState == SCPExternalize
                if (ballotStates[qs[nodeID].validators[n]].c.value == candidate.value) {
                    if (qs[nodeID].validators[n] != nodeID) {
                        cntVBlockTH++;
                    }
                }
            }

            if (cntVBlockTH &gt; totalValidators[nodeID] - qs[nodeID].threshold) {
                return true;
            }

            if (checkAcceptedPrepareQuorum(n, candidate)) {
                cntQuorumTH++;
            }

            if (cntQuorumTH &gt;= qs[nodeID].threshold) {
                return true;
            }
        }
    }

    return false;
}

bool attemptAcceptPrepare(SCPBallot &amp;acceptedBallot, SCPBallot &amp;newMessageBallots[3]) {
    bool isAgreed = false;
    bool hasNewAcceptedPrepare = false;
    SCPBallot tempBallot;

    for (n : int[0,N-1]) {
        if (qs[nodeID].validators[n] != N) {
            isAgreed = false;
            tempBallot.counter = 0;
            tempBallot.value = NOVALUE;
            if (ballotStates[qs[nodeID].validators[n]].curState == SCPPrepare) {
                for (j : int[0,2]) {
                    if (!isAgreed &amp;&amp; newMessageBallots[j].counter != 0) {
                        if (ballotStates[qs[nodeID].validators[n]].b.value == newMessageBallots[j].value
                            &amp;&amp; ballotStates[qs[nodeID].validators[n]].b.counter &lt;= newMessageBallots[j].counter) {
                            isAgreed = checkAcceptedPrepare(ballotStates[qs[nodeID].validators[n]].b);
                            if (isAgreed) {
                                tempBallot.counter = ballotStates[qs[nodeID].validators[n]].b.counter;
                                tempBallot.value = ballotStates[qs[nodeID].validators[n]].b.value;
                            }
                            else {
                                if (ballotStates[qs[nodeID].validators[n]].p.counter != 0
                                    &amp;&amp; (ballotStates[qs[nodeID].validators[n]].p.value == newMessageBallots[j].value
                                        &amp;&amp; ballotStates[qs[nodeID].validators[n]].p.counter &lt;= newMessageBallots[j].counter)) {
                                    isAgreed = checkAcceptedPrepare(ballotStates[qs[nodeID].validators[n]].p);
                                    if (isAgreed) {
                                        tempBallot.counter = ballotStates[qs[nodeID].validators[n]].p.counter;
                                        tempBallot.value = ballotStates[qs[nodeID].validators[n]].p.value;
                                    }
                                    else {
                                        if (ballotStates[qs[nodeID].validators[n]].pp.counter != 0
                                            &amp;&amp; (ballotStates[qs[nodeID].validators[n]].pp.value == newMessageBallots[j].value
                                                &amp;&amp; ballotStates[qs[nodeID].validators[n]].pp.counter &lt;= newMessageBallots[j].counter)) {
                                            isAgreed = checkAcceptedPrepare(ballotStates[qs[nodeID].validators[n]].pp);
                                            if (isAgreed) {
                                                tempBallot.counter = ballotStates[qs[nodeID].validators[n]].pp.counter;
                                                tempBallot.value = ballotStates[qs[nodeID].validators[n]].pp.value;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            else if (ballotStates[qs[nodeID].validators[n]].curState == SCPCommit) {
                for (j : int[0,2]) {
                    if (!isAgreed &amp;&amp; newMessageBallots[j].counter != 0) {
                        if (ballotStates[qs[nodeID].validators[n]].c.value == newMessageBallots[j].value) {
                            isAgreed = checkAcceptedPrepare(newMessageBallots[j]);
                            if (isAgreed) {
                                tempBallot.counter = newMessageBallots[j].counter;
                                tempBallot.value = newMessageBallots[j].value;
                            }
                            else {
                                if (ballotStates[qs[nodeID].validators[n]].p.counter &lt; newMessageBallots[j].counter) {
                                    tempBallot.counter = ballotStates[qs[nodeID].validators[n]].p.counter;
                                    tempBallot.value = newMessageBallots[j].value;
                                    isAgreed = checkAcceptedPrepare(tempBallot);
                                }
                            }
                        }
                    }
                }
            }
            else {// ballotStates[qs[nodeID].validators[n]].curState == SCPExternalize
                for (j : int[0,2]) {
                    if (!isAgreed &amp;&amp; newMessageBallots[j].counter != 0) {
                        if (ballotStates[qs[nodeID].validators[n]].c.value == newMessageBallots[j].value) {
                            isAgreed = checkAcceptedPrepare(newMessageBallots[j]);
                            if (isAgreed) {
                                tempBallot.counter = newMessageBallots[j].counter;
                                tempBallot.value = newMessageBallots[j].value;
                            }
                        }
                    }
                }
            }

            if (isAgreed) {
                hasNewAcceptedPrepare = true;
                if (acceptedBallot.counter &lt; tempBallot.counter
                    || (acceptedBallot.counter == tempBallot.counter
                        &amp;&amp; isLessValue(acceptedBallot.value, tempBallot.value))) { // acceptedBallot.value &lt; tempBallot.value
                    acceptedBallot.counter = tempBallot.counter;
                    acceptedBallot.value = tempBallot.value;
                }
            }
        }
    }

    return hasNewAcceptedPrepare;
}

bool checkConfirmedPrepareQuorum(int[0,N] nodeIndex, const SCPBallot &amp;candidate) {
    int[0,N] cntQuorumTH = 0;

    for (n : int[0,N-1]) {
        if (N - n + cntQuorumTH &lt; qs[nodeIndex].threshold) {
            return false;
        }

        if (qs[nodeIndex].validators[n] != N) {
            if (ballotStates[qs[nodeIndex].validators[n]].curState == SCPPrepare) {
                if ((ballotStates[qs[nodeIndex].validators[n]].p.counter != 0
                        &amp;&amp; (ballotStates[qs[nodeIndex].validators[n]].p.value == candidate.value
                            &amp;&amp; ballotStates[qs[nodeIndex].validators[n]].p.counter &gt;= candidate.counter))
                    || (ballotStates[qs[nodeIndex].validators[n]].pp.counter != 0
                        &amp;&amp; (ballotStates[qs[nodeIndex].validators[n]].pp.value == candidate.value
                            &amp;&amp; ballotStates[qs[nodeIndex].validators[n]].pp.counter &gt;= candidate.counter))) {
                    cntQuorumTH++;
                }
            }
            else if (ballotStates[qs[nodeIndex].validators[n]].curState == SCPCommit) {
                if (ballotStates[qs[nodeIndex].validators[n]].p.value == candidate.value
                    &amp;&amp; ballotStates[qs[nodeIndex].validators[n]].p.counter &gt;= candidate.counter) {
                    cntQuorumTH++;
                }
            }
            else {// ballotStates[qs[nodeIndex].validators[n]].curState == SCPExternalize
                if (ballotStates[qs[nodeIndex].validators[n]].c.value == candidate.value) {
                    cntQuorumTH++;
                }
            }

            if (cntQuorumTH &gt;= qs[nodeIndex].threshold) {
                return true;
            }
        }
    }

    return false;
}

bool checkConfirmedPrepare(const SCPBallot &amp;candidate) {
    int[0,N] cntQuorumTH = 0;

    for (n : int[0,N-1]) {
        if (N - n + cntQuorumTH &lt; qs[nodeID].threshold) {
            return false;
        }

        if (qs[nodeID].validators[n] != N) {
            if (checkConfirmedPrepareQuorum(n, candidate)) {
                cntQuorumTH++;
            }

            if (cntQuorumTH &gt;= qs[nodeID].threshold) {
                return true;
            }
        }
    }

    return false;
}

bool attemptConfirmPrepare(SCPBallot &amp;confirmedHBallot, SCPBallot &amp;newMessageBallots[3]) {
    bool isAgreed = false;
    bool hasNewConfirmedPrepare = false;
    SCPBallot tempBallot;

    for (n : int[0,N-1]) {
        if (qs[nodeID].validators[n] != N) {
            isAgreed = false;
            tempBallot.counter = 0;
            tempBallot.value = NOVALUE;
            if (ballotStates[qs[nodeID].validators[n]].curState == SCPPrepare) {
                for (j : int[0,2]) {
                    if (!isAgreed &amp;&amp; newMessageBallots[j].counter != 0) {
                        if (ballotStates[qs[nodeID].validators[n]].b.value == newMessageBallots[j].value
                            &amp;&amp; ballotStates[qs[nodeID].validators[n]].b.counter &lt;= newMessageBallots[j].counter) {
                            isAgreed = checkConfirmedPrepare(ballotStates[qs[nodeID].validators[n]].b);
                            if (isAgreed) {
                                tempBallot.counter = ballotStates[qs[nodeID].validators[n]].b.counter;
                                tempBallot.value = ballotStates[qs[nodeID].validators[n]].b.value;
                            }
                            else {
                                if (ballotStates[qs[nodeID].validators[n]].p.counter != 0
                                    &amp;&amp; (ballotStates[qs[nodeID].validators[n]].p.value == newMessageBallots[j].value
                                        &amp;&amp; ballotStates[qs[nodeID].validators[n]].p.counter &lt;= newMessageBallots[j].counter)) {
                                    isAgreed = checkConfirmedPrepare(ballotStates[qs[nodeID].validators[n]].p);
                                    if (isAgreed) {
                                        tempBallot.counter = ballotStates[qs[nodeID].validators[n]].p.counter;
                                        tempBallot.value = ballotStates[qs[nodeID].validators[n]].p.value;
                                    }
                                    else {
                                        if (ballotStates[qs[nodeID].validators[n]].pp.counter != 0
                                            &amp;&amp; (ballotStates[qs[nodeID].validators[n]].pp.value == newMessageBallots[j].value
                                                &amp;&amp; ballotStates[qs[nodeID].validators[n]].pp.counter &lt;= newMessageBallots[j].counter)) {
                                            isAgreed = checkConfirmedPrepare(ballotStates[qs[nodeID].validators[n]].pp);
                                            if (isAgreed) {
                                                tempBallot.counter = ballotStates[qs[nodeID].validators[n]].pp.counter;
                                                tempBallot.value = ballotStates[qs[nodeID].validators[n]].pp.value;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            else if (ballotStates[qs[nodeID].validators[n]].curState == SCPCommit) {
                for (j : int[0,2]) {
                    if (!isAgreed &amp;&amp; newMessageBallots[j].counter != 0) {
                        if (ballotStates[qs[nodeID].validators[n]].c.value == newMessageBallots[j].value) {
                            isAgreed = checkConfirmedPrepare(newMessageBallots[j]);
                            if (isAgreed) {
                                tempBallot.counter = newMessageBallots[j].counter;
                                tempBallot.value = newMessageBallots[j].value;
                            }
                            else {
                                if (ballotStates[qs[nodeID].validators[n]].p.counter &lt; newMessageBallots[j].counter) {
                                    tempBallot.counter = ballotStates[qs[nodeID].validators[n]].p.counter;
                                    tempBallot.value = newMessageBallots[j].value;
                                    isAgreed = checkConfirmedPrepare(tempBallot);
                                }
                            }
                        }
                    }
                }
            }
            else {// ballotStates[qs[nodeID].validators[n]].curState == SCPExternalize
                for (j : int[0,2]) {
                    if (!isAgreed &amp;&amp; newMessageBallots[j].counter != 0) {
                        if (ballotStates[qs[nodeID].validators[n]].c.value == newMessageBallots[j].value) {
                            isAgreed = checkConfirmedPrepare(newMessageBallots[j]);
                            if (isAgreed) {
                                tempBallot.counter = newMessageBallots[j].counter;
                                tempBallot.value = newMessageBallots[j].value;
                            }
                        }
                    }
                }
            }

            if (isAgreed) {
                if (ballotStates[nodeID].h.counter == 0
                    || (ballotStates[nodeID].h.counter &lt; tempBallot.counter
                        || (ballotStates[nodeID].h.counter == tempBallot.counter
                            &amp;&amp; isLessValue(ballotStates[nodeID].h.value, tempBallot.value)))) { // ballotStates[nodeID].h.value &lt; tempBallot.value
                    hasNewConfirmedPrepare = true;
                    if (confirmedHBallot.counter == 0) {
                        confirmedHBallot.counter = tempBallot.counter;
                        confirmedHBallot.value = tempBallot.value;
                    }
                    else {
                        if (confirmedHBallot.counter &lt; tempBallot.counter
                            || (confirmedHBallot.counter == tempBallot.counter
                                &amp;&amp; isLessValue(confirmedHBallot.value, tempBallot.value))) { // confirmedHBallot.value &lt; tempBallot.value
                            confirmedHBallot.counter = tempBallot.counter;
                            confirmedHBallot.value = tempBallot.value;
                        }
                    }
                }
            }
        }
    }

    return hasNewConfirmedPrepare;
}

void sortArr(int[0,N*3] len, int[0,INFINITY]&amp; arr[N*3]) {
    int[0,N*3] i,j,maxIndex;
    int[0,INFINITY] temp;

    for (i=0; i&lt;len; i++) {
        temp = arr[i];
        maxIndex = i;
        for (j=i+1; j&lt;len; j++) {
            if (temp &lt;= arr[j]) {
                temp = arr[j];
                maxIndex = j;
            }
        }
        arr[maxIndex] = arr[i];
        arr[i] = temp;
    }
}

bool checkAcceptedCommitQuorum(int[0,N] nodeIndex, const bool &amp;ballotValue[V], int[0,INFINITY] counterC, int[0,INFINITY] counterH) {
    int[0,N] cntQuorumTH = 0;
    bool isVBlocked = false;

    for (n : int[0,N-1]) {
        if (N - n + cntQuorumTH &lt; qs[nodeIndex].threshold) {
            return false;
        }

        if (qs[nodeIndex].validators[n] != N) {
            isVBlocked = false;
            if (ballotStates[qs[nodeIndex].validators[n]].curState == SCPPrepare) {
                if (ballotStates[qs[nodeIndex].validators[n]].b.value == ballotValue
                    &amp;&amp; ballotStates[qs[nodeIndex].validators[n]].h.counter &gt;= counterH) {
                    cntQuorumTH++;
                }
            }
            else if (ballotStates[qs[nodeIndex].validators[n]].curState == SCPCommit) {
                if (ballotStates[qs[nodeIndex].validators[n]].b.value == ballotValue
                    &amp;&amp; (ballotStates[qs[nodeIndex].validators[n]].c.counter &lt;= counterC
                        &amp;&amp; ballotStates[qs[nodeIndex].validators[n]].h.counter &gt;= counterH)) {
                    cntQuorumTH++;
                    isVBlocked = true;
                }
                if (!isVBlocked
                    &amp;&amp; (ballotStates[qs[nodeIndex].validators[n]].b.value == ballotValue
                        &amp;&amp; ballotStates[qs[nodeIndex].validators[n]].c.counter &lt;= counterC)) {
                    cntQuorumTH++;
                }
            }
            else {// ballotStates[qs[nodeIndex].validators[n]].curState == SCPExternalize
                if (ballotStates[qs[nodeIndex].validators[n]].c.value == ballotValue
                    &amp;&amp; ballotStates[qs[nodeIndex].validators[n]].c.counter &lt;= counterC) {
                    cntQuorumTH++;
                    isVBlocked = true;
                }
                if (!isVBlocked
                    &amp;&amp; (ballotStates[qs[nodeIndex].validators[n]].c.value == ballotValue
                        &amp;&amp; ballotStates[qs[nodeIndex].validators[n]].c.counter &lt;= counterC)) {
                    cntQuorumTH++;
                }
            }

            if (cntQuorumTH &gt;= qs[nodeIndex].threshold) {
                return true;
            }
        }
    }

    return false;
}

bool checkAcceptedCommit(const bool &amp;ballotValue[V], int[0,INFINITY] counterC, int[0,INFINITY] counterH) {
    int[0,N] cntVBlockTH = 0;
    int[0,N] cntQuorumTH = 0;

    for (n : int[0,N-1]) {
        if (qs[nodeID].validators[n] != N) {
            if (ballotStates[qs[nodeID].validators[n]].curState == SCPPrepare) {
                // do nothing
            }
            else if (ballotStates[qs[nodeID].validators[n]].curState == SCPCommit) {
                if (ballotStates[qs[nodeID].validators[n]].b.value == ballotValue
                    &amp;&amp; (ballotStates[qs[nodeID].validators[n]].c.counter &lt;= counterC
                        &amp;&amp; ballotStates[qs[nodeID].validators[n]].h.counter &gt;= counterH)) {
                    cntVBlockTH++;
                }
            }
            else {// ballotStates[qs[nodeID].validators[n]].curState == SCPExternalize
                if (ballotStates[qs[nodeID].validators[n]].c.value == ballotValue
                    &amp;&amp; ballotStates[qs[nodeID].validators[n]].c.counter &lt;= counterC) {
                    cntVBlockTH++;
                }
            }

            if (cntVBlockTH &gt; totalValidators[nodeID] - qs[nodeID].threshold) {
                return true;
            }

            if (checkAcceptedCommitQuorum(n, ballotValue, counterC, counterH)) {
                cntQuorumTH++;
            }

            if (cntQuorumTH &gt;= qs[nodeID].threshold) {
                return true;
            }
        }
    }

    return false;
}

bool attemptAcceptCommit(SCPBallot &amp;newMessageBallots[3], int[0,INFINITY] &amp;acceptedCounterC, int[0,INFINITY] &amp;acceptedCounterH) {
    int[0,N*3] k; // index for curBoundaries[N*3]
    int[0,INFINITY] curBoundaries[N*3];
    int[0,N*3] nextBoundary = 0;
    bool isAgreed = false;

    for (n : int[0,N-1]) {
        if (qs[nodeID].validators[n] != N) {
            if (ballotStates[qs[nodeID].validators[n]].curState == SCPPrepare
                &amp;&amp; ballotStates[qs[nodeID].validators[n]].b.value == newMessageBallots[0].value) {
                if (ballotStates[qs[nodeID].validators[n]].c.counter != 0) {
                    curBoundaries[nextBoundary++] = ballotStates[qs[nodeID].validators[n]].c.counter;
                }
                if (ballotStates[qs[nodeID].validators[n]].h.counter != 0) {
                    curBoundaries[nextBoundary++] = ballotStates[qs[nodeID].validators[n]].h.counter;
                }
            }
            else if (ballotStates[qs[nodeID].validators[n]].curState == SCPCommit
                &amp;&amp; ballotStates[qs[nodeID].validators[n]].b.value == newMessageBallots[0].value) {
                curBoundaries[nextBoundary++] = ballotStates[qs[nodeID].validators[n]].c.counter;
                curBoundaries[nextBoundary++] = ballotStates[qs[nodeID].validators[n]].h.counter;
            }
            else {// ballotStates[qs[nodeID].validators[n]].curState == SCPExternalize
                if (ballotStates[qs[nodeID].validators[n]].c.value == newMessageBallots[0].value) {
                    curBoundaries[nextBoundary++] = ballotStates[qs[nodeID].validators[n]].c.counter;
                    curBoundaries[nextBoundary++] = ballotStates[qs[nodeID].validators[n]].h.counter;
                    curBoundaries[nextBoundary++] = INFINITY;
                }
            }
        }
    }

    // sort curBoundaries[0 .. nextBoundary-1]: highest first
    sortArr(nextBoundary, curBoundaries);

    k = 0;
    acceptedCounterC = 0;
    acceptedCounterH = 0;
    isAgreed = false;
    do {
        if (acceptedCounterH == 0) {// find the high boundary
            if (checkAcceptedCommit(newMessageBallots[0].value, curBoundaries[k], curBoundaries[k])) {
                isAgreed = true;
                acceptedCounterH = curBoundaries[k];
                k++;
            }
            else {
                k++;
            }
        }
        else {// find the low boundary
            if (checkAcceptedCommit(newMessageBallots[0].value, curBoundaries[k], acceptedCounterH)) {
                acceptedCounterC = curBoundaries[k];
                k = nextBoundary;
            }
            else {
                k++;
            }
        }
    } while (acceptedCounterC == 0 &amp;&amp; k &lt; nextBoundary);

    return isAgreed;
}

bool checkConfirmedCommitQuorum(int[0,N] nodeIndex, const bool &amp;ballotValue[V], int[0,INFINITY] counterC, int[0,INFINITY] counterH) {
    int[0,N] cntQuorumTH = 0;

    for (n : int[0,N-1]) {
        if (N - n + cntQuorumTH &lt; qs[nodeIndex].threshold) {
            return false;
        }

        if (qs[nodeIndex].validators[n] != N) {
            if (ballotStates[qs[nodeIndex].validators[n]].curState == SCPPrepare) {
                // do nothing
            }
            else if (ballotStates[qs[nodeIndex].validators[n]].curState == SCPCommit) {
                if (ballotStates[qs[nodeIndex].validators[n]].b.value == ballotValue
                    &amp;&amp; ballotStates[qs[nodeIndex].validators[n]].c.counter &lt;= counterC
                    &amp;&amp; ballotStates[qs[nodeIndex].validators[n]].h.counter &gt;= counterH) {
                    cntQuorumTH++;
                }
            }
            else {// ballotStates[qs[nodeIndex].validators[n]].curState == SCPExternalize
                if (ballotStates[qs[nodeIndex].validators[n]].c.value == ballotValue
                    &amp;&amp; ballotStates[qs[nodeIndex].validators[n]].c.counter &lt;= counterC) {
                    cntQuorumTH++;
                }
            }

            if (cntQuorumTH &gt;= qs[nodeIndex].threshold) {
                return true;
            }
        }
    }

    return false;
}

bool checkConfirmedCommit(const bool &amp;ballotValue[V], int[0,INFINITY] counterC, int[0,INFINITY] counterH) {
    int[0,N] cntQuorumTH = 0;

    for (n : int[0,N-1]) {
        if (qs[nodeID].validators[n] != N) {
            if (N - n + cntQuorumTH &lt; qs[nodeID].threshold) {
                return false;
            }

            if (checkConfirmedCommitQuorum(n, ballotValue, counterC, counterH)) {
                cntQuorumTH++;
            }

            if (cntQuorumTH &gt;= qs[nodeID].threshold) {
                return true;
            }
        }
    }

    return false;
}

bool attemptConfirmCommit(SCPBallot &amp;newMessageBallots[3], int[0,INFINITY] &amp;acceptedCounterC, int[0,INFINITY] &amp;acceptedCounterH) {
    int[0,N*3] k; // index for curBoundaries[N*3]
    int[0,INFINITY] curBoundaries[N*3];
    int[0,N*3] nextBoundary = 0;
    bool isAgreed = false;

    for (n : int[0,N-1]) {
        if (qs[nodeID].validators[n] != N) {
            if (ballotStates[qs[nodeID].validators[n]].curState == SCPPrepare) {
                // do nothing
            }
            else if (ballotStates[qs[nodeID].validators[n]].curState == SCPCommit
                &amp;&amp; ballotStates[qs[nodeID].validators[n]].b.value == newMessageBallots[0].value) {
                curBoundaries[nextBoundary++] = ballotStates[qs[nodeID].validators[n]].c.counter;
                curBoundaries[nextBoundary++] = ballotStates[qs[nodeID].validators[n]].h.counter;
            }
            else {// ballotStates[qs[nodeID].validators[n]].curState == SCPExternalize
                if (ballotStates[qs[nodeID].validators[n]].c.value == newMessageBallots[0].value) {
                    curBoundaries[nextBoundary++] = ballotStates[qs[nodeID].validators[n]].c.counter;
                    curBoundaries[nextBoundary++] = ballotStates[qs[nodeID].validators[n]].h.counter;
                    curBoundaries[nextBoundary++] = INFINITY;
                }
            }
        }
    }

    // sort curBoundaries[0 .. nextBoundary-1]: highest first
    sortArr(nextBoundary, curBoundaries);

    k = 0;
    acceptedCounterC = 0;
    acceptedCounterH = 0;
    isAgreed = false;
    do {
        if (acceptedCounterH == 0) {// find the high boundary
            if (checkConfirmedCommit(newMessageBallots[0].value, curBoundaries[k], curBoundaries[k])) {
                isAgreed = true;
                acceptedCounterH = curBoundaries[k];
                k++;
            }
            else {
                k++;
            }
        }
        else {// find the low boundary
            if (checkConfirmedCommit(newMessageBallots[0].value, curBoundaries[k], acceptedCounterH)) {
                acceptedCounterC = curBoundaries[k];
                k = nextBoundary;
            }
            else {
                k++;
            }
        }
    } while (acceptedCounterC == 0 &amp;&amp; k &lt; nextBoundary);

    return isAgreed;
}

void processMessagePrepare() {
    bool hasNewBallot = false;
    int[0,N-1] newMessageNode = nodeID;
    int[0,INFINITY] acceptedCounterC = 0;
    int[0,INFINITY] acceptedCounterH = 0;
    SCPBallot newBallot;
    SCPBallot newMessageBallots[3];

    for (n : int[0,N-1]) {
        if (qs[nodeID].validators[n] != N &amp;&amp; qs[nodeID].validators[n] != nodeID) {
            if (ballotStates[qs[nodeID].validators[n]].b.counter &gt;= ballotStates[nodeID].b.counter) {
                if (newMessageNode == nodeID) {
                    newMessageNode = qs[nodeID].validators[n];
                }
                else {
                    if (ballotStates[qs[nodeID].validators[n]].b.counter &gt; ballotStates[newMessageNode].b.counter) {
                        newMessageNode = qs[nodeID].validators[n];
                    }
                }
            }
        }
    }
    if (newMessageNode == nodeID) {
        return;
    }

    if (ballotStates[newMessageNode].curState == SCPPrepare) {
        newMessageBallots[0].counter = ballotStates[newMessageNode].b.counter;
        newMessageBallots[0].value = ballotStates[newMessageNode].b.value;
        newMessageBallots[1].counter = ballotStates[newMessageNode].p.counter;
        newMessageBallots[1].value = ballotStates[newMessageNode].p.value;
        newMessageBallots[2].counter = ballotStates[newMessageNode].pp.counter;
        newMessageBallots[2].value = ballotStates[newMessageNode].pp.value;
    }
    else if (ballotStates[newMessageNode].curState == SCPCommit) {
        newMessageBallots[0].counter = ballotStates[newMessageNode].p.counter;
        newMessageBallots[0].value = ballotStates[newMessageNode].b.value;
        newMessageBallots[1].counter = INFINITY;
        newMessageBallots[1].value = ballotStates[newMessageNode].b.value;
        newMessageBallots[2].counter = 0;
        newMessageBallots[2].value = NOVALUE;
    }
    else {// ballotStates[newMessageNode].curState == SCPExternalize
        newMessageBallots[0].counter = INFINITY;
        newMessageBallots[0].value = ballotStates[newMessageNode].c.value;
        newMessageBallots[1].counter = 0;
        newMessageBallots[1].value = NOVALUE;
        newMessageBallots[2].counter = 0;
        newMessageBallots[2].value = NOVALUE;
    }

    // blocking threshold check for b.counter

    // blocking threshold check for accept prepare ballots (attemptAcceptPrepare)
    // quorum threshold check for vote prepare ballots (attemptAcceptPrepare)
    newBallot.counter = 0;
    newBallot.value = NOVALUE;
    hasNewBallot = attemptAcceptPrepare(newBallot, newMessageBallots);

    if (hasNewBallot) {
        // update p or pp
        if (ballotStates[nodeID].p.counter == 0) {
            ballotStates[nodeID].p.counter = newBallot.counter;
            ballotStates[nodeID].p.value = newBallot.value;
        }
        else {
            if (ballotStates[nodeID].p.counter &lt; newBallot.counter
                || (ballotStates[nodeID].p.counter == newBallot.counter
                    &amp;&amp; isLessValue(ballotStates[nodeID].p.value, newBallot.value))) { // ballotStates[nodeID].p.value &lt; newBallot.value
                if (ballotStates[nodeID].p.value != newBallot.value) {
                    ballotStates[nodeID].pp.counter = ballotStates[nodeID].p.counter;
                    ballotStates[nodeID].pp.value = ballotStates[nodeID].p.value;
                }
                ballotStates[nodeID].p.counter = newBallot.counter;
                ballotStates[nodeID].p.value = newBallot.value;
            }
            else if (ballotStates[nodeID].p.counter &gt; newBallot.counter
                || (ballotStates[nodeID].p.counter == newBallot.counter
                    &amp;&amp; isLessValue(newBallot.value, ballotStates[nodeID].p.value))) { // ballotStates[nodeID].p.value &gt; newBallot.value
                if (ballotStates[nodeID].pp.counter == 0
                    || (ballotStates[nodeID].pp.counter &lt; newBallot.counter
                        || (ballotStates[nodeID].pp.counter == newBallot.counter
                            &amp;&amp; isLessValue(ballotStates[nodeID].pp.value, newBallot.value)))) { // ballotStates[nodeID].pp.value &lt; newBallot.value
                    if (ballotStates[nodeID].p.value != newBallot.value) {
                        ballotStates[nodeID].pp.counter = newBallot.counter;
                        ballotStates[nodeID].pp.value = newBallot.value;
                    }
                }
            }
        }

        // clare c if required
        if (ballotStates[nodeID].c.counter != 0
            &amp;&amp; ballotStates[nodeID].h.counter != 0
            &amp;&amp; ((ballotStates[nodeID].p.counter != 0
                    &amp;&amp; ballotStates[nodeID].h.value != ballotStates[nodeID].p.value
                    &amp;&amp; ballotStates[nodeID].h.counter &lt; ballotStates[nodeID].p.counter)
                || (ballotStates[nodeID].pp.counter != 0
                    &amp;&amp; ballotStates[nodeID].h.value != ballotStates[nodeID].pp.value
                    &amp;&amp; ballotStates[nodeID].h.counter &lt; ballotStates[nodeID].pp.counter))) {
            ballotStates[nodeID].c.counter = 0;
            ballotStates[nodeID].c.value = NOVALUE;
        }
    }

    // quorum threshold check for accept prepare ballots (attemptConfirmPrepare)
    if (ballotStates[nodeID].p.counter != 0) {
        newBallot.counter = 0;
        newBallot.value = NOVALUE;
        hasNewBallot = attemptConfirmPrepare(newBallot, newMessageBallots);

        if (hasNewBallot) {
            // update h or c
            if (newBallot.counter != 0) {
                ballotStates[nodeID].h.counter = newBallot.counter;
                ballotStates[nodeID].h.value = newBallot.value;
                if (ballotStates[nodeID].c.counter == 0
                    &amp;&amp; (ballotStates[nodeID].p.counter == 0
                        || !(ballotStates[nodeID].p.value != newBallot.value
                            &amp;&amp; ballotStates[nodeID].p.counter &lt;= newBallot.counter))
                    &amp;&amp; (ballotStates[nodeID].pp.counter == 0
                        || !(ballotStates[nodeID].pp.value != newBallot.value
                            &amp;&amp; ballotStates[nodeID].pp.counter &lt;= newBallot.counter))
                    &amp;&amp; (ballotStates[nodeID].b.counter &lt; newBallot.counter
                        || (ballotStates[nodeID].b.counter == newBallot.counter
                            &amp;&amp; !isLessValue(newBallot.value, ballotStates[nodeID].b.value)))) { // ballotStates[nodeID].b.value &lt;= newBallot.value
                    ballotStates[nodeID].c.counter = newBallot.counter;
                    ballotStates[nodeID].c.value = newBallot.value;
                }
            }

            // bump b if required
            if (ballotStates[nodeID].b.counter == 0
                || (ballotStates[nodeID].b.counter &lt; ballotStates[nodeID].h.counter
                    || (ballotStates[nodeID].b.counter == ballotStates[nodeID].h.counter
                        &amp;&amp; isLessValue(ballotStates[nodeID].b.value, ballotStates[nodeID].h.value)))) { // ballotStates[nodeID].b.value &lt; ballotStates[nodeID].h.value
                ballotStates[nodeID].b.counter = ballotStates[nodeID].h.counter;
                ballotStates[nodeID].b.value = ballotStates[nodeID].h.value;
            }
        }
    }

    // blocking threshold check for accept commit ballots (attemptAcceptCommit)
    // quorum threshold check for vote commit ballots (attemptAcceptCommit)
    if (ballotStates[newMessageNode].h.counter != 0) {
        newMessageBallots[0].counter = ballotStates[newMessageNode].h.counter;
        if (ballotStates[newMessageNode].curState == SCPExternalize) {
            newMessageBallots[0].value = ballotStates[newMessageNode].c.value;
        }
        else {
            newMessageBallots[0].value = ballotStates[newMessageNode].b.value;
        }

        hasNewBallot = attemptAcceptCommit(newMessageBallots, acceptedCounterC, acceptedCounterH);

        if (hasNewBallot) {
            if (acceptedCounterC == 0) {
                acceptedCounterC = acceptedCounterH;
            }

            ballotStates[nodeID].c.counter = acceptedCounterC;
            ballotStates[nodeID].c.value = newMessageBallots[0].value;
            ballotStates[nodeID].h.counter = acceptedCounterH;
            ballotStates[nodeID].h.value = newMessageBallots[0].value;
            ballotStates[nodeID].curState = SCPCommit;
            ballotStates[nodeID].pp.counter = 0;
            ballotStates[nodeID].pp.value = NOVALUE;
        }
    }

    if (ballotStates[nodeID].h.counter &gt; ballotStates[nodeID].b.counter) {
        ballotStates[nodeID].b.counter = ballotStates[nodeID].h.counter;
        ballotStates[nodeID].b.value = ballotStates[nodeID].h.value;
    }
}

void processMessageCommit() {
    bool hasNewBallot = false;
    int[0,N-1] newMessageNode = nodeID;
    int[0,INFINITY] acceptedCounterC = 0;
    int[0,INFINITY] acceptedCounterH = 0;
    SCPBallot newBallot;
    SCPBallot newMessageBallots[3];

    for (n : int[0,N-1]) {
        if (qs[nodeID].validators[n] != N &amp;&amp; qs[nodeID].validators[n] != nodeID) {
            if (ballotStates[qs[nodeID].validators[n]].b.counter &gt;= ballotStates[nodeID].b.counter) {
                if (newMessageNode == nodeID) {
                    newMessageNode = qs[nodeID].validators[n];
                }
                else {
                    if (ballotStates[qs[nodeID].validators[n]].b.counter &gt; ballotStates[newMessageNode].b.counter) {
                        newMessageNode = qs[nodeID].validators[n];
                    }
                }
            }
        }
    }
    if (newMessageNode == nodeID) {
        return;
    }

    if (ballotStates[newMessageNode].curState == SCPPrepare) {
        newMessageBallots[0].counter = ballotStates[newMessageNode].b.counter;
        newMessageBallots[0].value = ballotStates[newMessageNode].b.value;
        newMessageBallots[1].counter = ballotStates[newMessageNode].p.counter;
        newMessageBallots[1].value = ballotStates[newMessageNode].p.value;
        newMessageBallots[2].counter = ballotStates[newMessageNode].pp.counter;
        newMessageBallots[2].value = ballotStates[newMessageNode].pp.value;
    }
    else if (ballotStates[newMessageNode].curState == SCPCommit) {
        newMessageBallots[0].counter = ballotStates[newMessageNode].p.counter;
        newMessageBallots[0].value = ballotStates[newMessageNode].b.value;
        newMessageBallots[1].counter = INFINITY;
        newMessageBallots[1].value = ballotStates[newMessageNode].b.value;
        newMessageBallots[2].counter = 0;
        newMessageBallots[2].value = NOVALUE;
    }
    else {// ballotStates[newMessageNode].curState == SCPExternalize
        newMessageBallots[0].counter = INFINITY;
        newMessageBallots[0].value = ballotStates[newMessageNode].c.value;
        newMessageBallots[1].counter = 0;
        newMessageBallots[1].value = NOVALUE;
        newMessageBallots[2].counter = 0;
        newMessageBallots[2].value = NOVALUE;
    }

    // blocking threshold check for b.counter

    // blocking threshold check for accept prepare ballots (attemptAcceptPrepare)
    // quorum threshold check for vote prepare ballots (attemptAcceptPrepare)
    newBallot.counter = 0;
    newBallot.value = NOVALUE;
    hasNewBallot = attemptAcceptPrepare(newBallot, newMessageBallots);

    if (hasNewBallot) {
        // update p or pp
        if (ballotStates[nodeID].p.counter == 0) {
            ballotStates[nodeID].p.counter = newBallot.counter;
            ballotStates[nodeID].p.value = newBallot.value;
        }
        else {
            if (ballotStates[nodeID].p.counter &lt; newBallot.counter
                || (ballotStates[nodeID].p.counter == newBallot.counter
                    &amp;&amp; isLessValue(ballotStates[nodeID].p.value, newBallot.value))) { // ballotStates[nodeID].p.value &lt; newBallot.value
                if (ballotStates[nodeID].p.value != newBallot.value) {
                    ballotStates[nodeID].pp.counter = ballotStates[nodeID].p.counter;
                    ballotStates[nodeID].pp.value = ballotStates[nodeID].p.value;
                }
                ballotStates[nodeID].p.counter = newBallot.counter;
                ballotStates[nodeID].p.value = newBallot.value;
            }
            else if (ballotStates[nodeID].p.counter &gt; newBallot.counter
                || (ballotStates[nodeID].p.counter == newBallot.counter
                    &amp;&amp; isLessValue(newBallot.value, ballotStates[nodeID].p.value))) { // ballotStates[nodeID].p.value &gt; newBallot.value
                if (ballotStates[nodeID].pp.counter == 0
                    || (ballotStates[nodeID].pp.counter &lt; newBallot.counter
                        || (ballotStates[nodeID].pp.counter == newBallot.counter
                            &amp;&amp; isLessValue(ballotStates[nodeID].pp.value, newBallot.value)))) { // ballotStates[nodeID].pp.value &lt; newBallot.value
                    if (ballotStates[nodeID].p.value != newBallot.value) {
                        ballotStates[nodeID].pp.counter = newBallot.counter;
                        ballotStates[nodeID].pp.value = newBallot.value;
                    }
                }
            }
        }
    }

    // blocking threshold check for accept commit ballots (attemptAcceptCommit)
    // quorum threshold check for vote commit ballots (attemptAcceptCommit)
    if (ballotStates[newMessageNode].h.counter != 0) {
        newMessageBallots[0].counter = ballotStates[newMessageNode].h.counter;
        if (ballotStates[newMessageNode].curState == SCPExternalize) {
            newMessageBallots[0].value = ballotStates[newMessageNode].c.value;
        }
        else {
            newMessageBallots[0].value = ballotStates[newMessageNode].b.value;
        }

        hasNewBallot = attemptAcceptCommit(newMessageBallots, acceptedCounterC, acceptedCounterH);

        if (hasNewBallot) {
            if (acceptedCounterC == 0) {
                acceptedCounterC = acceptedCounterH;
            }

            ballotStates[nodeID].c.counter = acceptedCounterC;
            ballotStates[nodeID].c.value = newMessageBallots[0].value;
            ballotStates[nodeID].h.counter = acceptedCounterH;
            ballotStates[nodeID].h.value = newMessageBallots[0].value;
            ballotStates[nodeID].pp.counter = 0;
            ballotStates[nodeID].pp.value = NOVALUE;
        }
    }

    // quorum threshold check for accept commit ballots (attemptConfirmCommit)
    if (ballotStates[newMessageNode].curState != SCPPrepare) {
        newMessageBallots[0].counter = ballotStates[newMessageNode].h.counter;
        if (ballotStates[newMessageNode].curState == SCPExternalize) {
            newMessageBallots[0].value = ballotStates[newMessageNode].c.value;
        }
        else {
            newMessageBallots[0].value = ballotStates[newMessageNode].b.value;
        }

        hasNewBallot = attemptConfirmCommit(newMessageBallots, acceptedCounterC, acceptedCounterH);

        if (hasNewBallot) {
            if (acceptedCounterC == 0) {
                acceptedCounterC = acceptedCounterH;
            }

            ballotStates[nodeID].c.counter = acceptedCounterC;
            ballotStates[nodeID].c.value = newMessageBallots[0].value;
            ballotStates[nodeID].h.counter = acceptedCounterH;
            ballotStates[nodeID].h.value = newMessageBallots[0].value;
            ballotStates[nodeID].curState = SCPExternalize;
            ballotStates[nodeID].b.counter = INFINITY;
        }
    }

    if (ballotStates[nodeID].h.counter &gt; ballotStates[nodeID].b.counter) {
        ballotStates[nodeID].b.counter = ballotStates[nodeID].h.counter;
        ballotStates[nodeID].b.value = ballotStates[nodeID].h.value;
    }
}

void newBCounter() {
    if (ballotStates[nodeID].curState == SCPPrepare) {
        processMessagePrepare();

        if (ballotStates[nodeID].b.counter&lt;INFINITY) {
            ballotStates[nodeID].b.counter++;
        }
        updatebValue();
    }
    else if (ballotStates[nodeID].curState == SCPCommit) {
        processMessageCommit();

        if (ballotStates[nodeID].b.counter&lt;INFINITY) {
            ballotStates[nodeID].b.counter++;
        }
        updatebValue();
    }
    else {// ballotStates[nodeID].curState == SCPExternalize
        // do nothing
    }

    n_clockBCounter = 0;
}
</declaration>
		<location id="id18" x="-1079" y="-501">
			<name x="-1062" y="-527">Prepare</name>
		</location>
		<location id="id19" x="-1266" y="-501">
			<name x="-1249" y="-527">StartBallot</name>
		</location>
		<location id="id20" x="-756" y="-501">
			<name x="-739" y="-527">Commit</name>
		</location>
		<location id="id21" x="-407" y="-501">
			<name x="-493" y="-527">Externalize</name>
		</location>
		<init ref="id19"/>
		<transition>
			<source ref="id21"/>
			<target ref="id19"/>
			<label kind="synchronisation" x="-1249" y="-739">slotSuccess?</label>
			<label kind="assignment" x="-1249" y="-765">resetBallotState()</label>
			<nail x="-408" y="-714"/>
			<nail x="-1266" y="-714"/>
		</transition>
		<transition>
			<source ref="id20"/>
			<target ref="id21"/>
			<label kind="guard" x="-739" y="-493">ballotStates[nodeID].curState == SCPExternalize</label>
			<label kind="assignment" x="-663" y="-467">ballotDone[nodeID] = true</label>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id20"/>
			<label kind="guard" x="-1062" y="-493">ballotStates[nodeID].curState == SCPCommit</label>
			<label kind="synchronisation" x="-1002" y="-467">nominationDone[nodeID]!</label>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id18"/>
			<label kind="guard" x="-1258" y="-391">n_clockBCounter &gt; ballotStates[nodeID].b.counter + 1
&amp;&amp; ballotStates[nodeID].curState == SCPPrepare
&amp;&amp; hasGEbCounter()</label>
			<label kind="assignment" x="-1122" y="-331">newBCounter()</label>
			<nail x="-1121" y="-399"/>
			<nail x="-1036" y="-399"/>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id18"/>
			<label kind="synchronisation" x="-1249" y="-493">sthNominated[nodeID]?</label>
			<label kind="assignment" x="-1249" y="-467">initBallotState()</label>
		</transition>
		<transition>
			<source ref="id20"/>
			<target ref="id20"/>
			<label kind="guard" x="-901" y="-391">n_clockBCounter &gt; ballotStates[nodeID].b.counter + 1
&amp;&amp; ballotStates[nodeID].curState == SCPCommit
&amp;&amp; hasGEbCounter()</label>
			<label kind="assignment" x="-799" y="-331">newBCounter()</label>
			<nail x="-798" y="-399"/>
			<nail x="-713" y="-399"/>
		</transition>
	</template>
	<system>//system NodeSlot, NodeNomination, NodeBallot;

system NodeSlot, NodeNomination, NodeBallot, NodeCheckNomination;</system>
	<queries>
		<query>
			<formula>E&lt;&gt; forall (i : int[0,SLOTMAX-1]) NodeSlot(i).SlotSuccess
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>A[] forall (i : s_id) not NodeSlot(i).SlotFail
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>A[] forall (i : s_id) not (NodeSlot(i).SlotFail || NodeSlot(i).SlotUnknown)
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>A[] forall (i : s_id) not (NodeSlot(i).SlotFail || NodeSlot(i).SlotUnknown || NodeSlot(i).SlotDeadlock)
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>A[] forall (i : v_id) not NodeCheckNomination(i).CheckNominationFail
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>A[] forall (i : n_id) ballotStates[i].c.counter != 0 imply (ballotStates[i].c.value == ballotStates[i].h.value &amp;&amp; ballotStates[i].c.counter &lt;= ballotStates[i].h.counter) &amp;&amp; (ballotStates[i].h.value == ballotStates[i].b.value &amp;&amp; ballotStates[i].h.counter &lt;= ballotStates[i].b.counter)
			</formula>
			<comment>
			</comment>
		</query>
	</queries>
</nta>
